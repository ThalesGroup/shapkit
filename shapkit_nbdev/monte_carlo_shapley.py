# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/monte_carlo_shapley.ipynb (unless otherwise specified).

__all__ = ['MonteCarloShapley']

# Cell
import numpy as np
import pandas as pd
from tqdm import tqdm

# Cell
def MonteCarloShapley(x, fc, r, n_iter, callback=None):
    """
    Estimate the Shapley Values using an optimized Monte Carlo version.
    """
    # Get general information
    f_r = fc(r.values)
    feature_names = list(x.index)
    d = len(feature_names) # dimension

    # If x[j] = r[j] => Φ[j] = 0 and we can reduce the dimension
    distinct_feature_names = list(x[x!=r].index)
    if set(distinct_feature_names) == set(feature_names):
        distinct_feature_names = feature_names
        sub_d = d
        x_cp = x.copy()
        r_cp = r.copy()
        reward = lambda z: fc(z)
        pass
    else:
        sub_d = len(distinct_feature_names) # new dimension
        x_cp = x[distinct_feature_names].copy()
        r_cp = r[distinct_feature_names].copy()
        print("new dimension {0}".format(sub_d))
        def reward(z):
            z_tmp = r.copy()
            z_tmp[distinct_feature_names] = z
            return fc(z_tmp.values)

    # Store all Shapley Values in a numpy array
    Φ_storage = np.empty((n_iter, sub_d))

    # Monte Carlo loop
    for m in tqdm(range(1, n_iter+1)):
        # Sample a random permutation order
        o = np.random.permutation(sub_d)
        # init useful variables for this iteration
        f_less_j = f_r
        x_plus_j = r_cp.values.copy()
        for j in o:
            x_plus_j[j] = x_cp.values[j]
            f_plus_j = reward(x_plus_j)
            # update Φ
            Φ_j = f_plus_j - f_less_j
            Φ_storage[m-1,j] = Φ_j
            # reassign f_less_j
            f_less_j = f_plus_j
        if callback:
            Φ = pd.Series(np.mean(Φ_storage[:m,:],axis=0), index=feature_names)
            callback(Φ)

    Φ_mean = np.mean(Φ_storage,axis=0)
    Φ = pd.Series(np.zeros(d), index=feature_names)
    Φ[distinct_feature_names] = Φ_mean
    return Φ